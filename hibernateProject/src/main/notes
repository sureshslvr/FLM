Hibernate notes:
need two dependencies mysql connector j and hibernate core ORM

steps:
@Entity and @ID in pojo class
hibernate.cfg.xml-> will add all data related to url,username,password
Configuration
    -> configure(hibernate.cfg.xml)//config file
    ->configuration.addAnnotatedClass(Employees.class)//add pojo class
    ->buildSessionFactory
Session Factory
session

dirty checking:
    when we do update/change data after loading data from data base, without merge/pushing again db automatically updates
    because of persistent, so unless required don't modify data in db
States in Hibernate: 3 states we have
    1) transient:
        not associated with any session
        ex: Employee emp=new Employee()
    2) persistent:
        object is associated or linked with session
        ex: when we do session.persist(emp) or session.find(Employee.class,1)
        with persistent object we have problem of dirty checking
    3) detached:
        Objects gets detached when session is closed,
        session is closed there is no link between session and objects
        once session is closed there is no dirty checking problem

@Table:
    when your table name is diff in database and ClassName use this annotation over pojo class
    ex: @Table(name = "employees")
@Column:
    when column name and java class field name is diff we get error, so we need to use @Column over field
    ex: @Column(name = "salary")
         private double sal;

@GeneratedValue(strategy = GenerationType.IDENTITY):
    -generated value fetch the value generated by sql,used when we use auto increment in table id
    -to verify run in debug mode and check

HQL:
    for doing DQL or select operation we can use below method
        query=session.createSelectionQuery("from Employee where name=?1",Employee.class);
        query.setParameter(1,"sfks");
        list = query.list();
        System.out.println(list);

    for DML: insert,delete,Udpate
        session.beginTransaction();
        query=session.createMutationQuery("Insert into Employee(column1,coulumn2,etc) values(?1,?2,?3));
        query.setParameter(1,"sjfj");
        query.setParameter(2,"tester");
        query.setParameter(3,40000);
        query.executeUpdate()
        session.getTransaction().commit();


NativeQuery:
    original query - sql query
    this are same as HQL just method will change here
    session.createNativeQuery() for dql opertaions
    session.createNativeMutationQuery() for DML operation
    here we need to write sql query here 

    ex:session.createNativeQuery("select * from employees",Employee.class)

Note: In HQL we should give field/table name as per Entiti/pojo class
      In Native Query we need to give table and column names as per Sql dataBase

Composite Primary key:
    its combination of two columns.
    In hebernate to do this we will write them in seperate pojo class(@Embeddable) with Two columns that used in composite primary key
    use that class as has relationship in Entity class and above filed add annotation @EmbeddedID
    
Named Queries: like stored procedure
    execution will be faster here becuase precompiled query
    to do it add @NamedQurey annotation in Entity class and call that  
    ex: @NamedQuery(name="allempl", query="from Employee") //Hql query
    session.createNamedQuery("allempl",Employee.class);
    
    if you want to writte multiple named quries,we can write insite brackets of @NamedQueries({@NamedQuery(),@NamedQuery()})
  
Mappings: we have four type of mappings, we use has a relationship here
    1. One to One:  
        user->passport(one user had one passport only)
        user and passort are seperate classes and we use Has a Relationship
        annotate @OneToOne over passport field in user class and @joinCoumn(name="pass_id") to create a forign key bw user and passport

    2. One to Many:
        User->Order( one user  can have many order)
    3. Many to One:
        Order->User( many order can placed by one User)
    4. Many to Many:
        studednts -> mutliple courses
        courses-> mutliple students
        

we don't use this ddl from java
<property name="hbm2ddl.auto">create</property>:
    it will drop and create table so there is a data loss
<property name="hbm2ddl.auto">update</property>:
    it will create table if does not exist
    else update the data in existing table
<property name="hbm2ddl.auto">create-drop</property>:
    same like create drop and create when session ended

