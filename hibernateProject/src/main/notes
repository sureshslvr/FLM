Hibernate notes:
need two dependencies mysql connector j and hibernate core ORM

steps:
@Entity and @ID in pojo class
hibernate.cfg.xml-> will add all data related to url,username,password
Configuration
    -> configure(hibernate.cfg.xml)//config file
    ->configuration.addAnnotatedClass(Employees.class)//add pojo class
    ->buildSessionFactory
Session Factory
session

dirty checking:
    when we do update/change data after loading data from data base, without merge/pushing again db automatically updates
    because of persistent, so unless required don't modify data in db
States in Hibernate: 3 states we have
    1) transient:
        not associated with any session
        ex: Employee emp=new Employee()
    2) persistent:
        object is associated or linked with session
        ex: when we do session.persist(emp) or session.find(Employee.class,1)
        with persistent object we have problem of dirty checking
    3) detached:
        Objects gets detached when session is closed,
        session is closed there is no link between session and objects
        once session is closed there is no dirty checking problem

@Table:
    when your table name is diff in database and ClassName use this annotation over pojo class
    ex: @Table(name = "employees")
@Column:
    when column name and java class field name is diff we get error, so we need to use @Column over field
    ex: @Column(name = "salary")
         private double sal;

@GeneratedValue(strategy = GenerationType.IDENTITY):
    -generated value fetch the value generated by sql,used when we use auto increment in table id
    -to verify run in debug mode and check

HQL:
    for doing DQL or select operation we can use below method
        query=session.createSelectionQuery("from Employee where name=?1",Employee.class);
        query.setParameter(1,"sfks");
        list = query.list();
        System.out.println(list);

    for DML: insert,delete,Update
        session.beginTransaction();
        query=session.createMutationQuery("Insert into Employee(column1,coulumn2,etc) values(?1,?2,?3));
        query.setParameter(1,"sjfj");
        query.setParameter(2,"tester");
        query.setParameter(3,40000);
        query.executeUpdate()
        session.getTransaction().commit();


NativeQuery:
    original query - sql query
    this are same as HQL just method will change here
    session.createNativeQuery() for dql operations
    session.createNativeMutationQuery() for DML operation
    here we need to write sql query here 

    ex:session.createNativeQuery("select * from employees",Employee.class)

Note: In HQL we should give field/table name as per Entity/pojo class
      In Native Query we need to give table and column names as per Sql dataBase

Composite Primary key:
    its combination of two columns.
    In hibernate to do this we will write them in separate pojo class(@Embeddable) with Two columns that used in composite primary key
    use that class as has relationship in Entity class and above filed add annotation @EmbeddedID
    
Named Queries: like stored procedure
    execution will be faster here because precompiled query
    to do it add @NamedQuery annotation in Entity class and call that
    ex: @NamedQuery(name="allempl", query="from Employee") //Hql query
    @NamedNativeQuery(name="allempl", query="select * from Employee", resultClass= Employee.class) //sql query
    session.createNamedQuery("allempl",Employee.class);
    
    if you want to write multiple named queries,we can write inside brackets of @NamedQueries({@NamedQuery(),@NamedQuery()})
  
Mappings: we have four type of mappings, we use has a relationship here
    1. One to One:  
        unidirectional one to one: 
        user->passport(one user had one passport only)
        user and passport are seperate classes and we use Has a Relationship
        annotate @OneToOne over passport field in user class and @joinColumn(name="pass_id") to create a foreign key bw user and passport
        inside OnetoOne brackets we need to use cascading to persist or save passport object before user as it is using foreign key
        ex: @OneToOne(Cascade = caseCadetype.Persists)

        biDirectional One to One:
        if you try to access user details form passport we don't get bcz it unidirectional,
        to make bidirectional add user in passport as has a relation and add annotation @OneToOne(mappedBy="passPort")// mapped by means refer the user
        use two classes instance variable and set user and passport using setter methods
        and get user detail using getter method of passport
        
    2. One to Many:
        User->Order( one user  can have many order)
    3. Many to One:
        Order->User( many order can placed by one User)
    4. Many to Many:
        students -> multiple courses
        courses-> multiple students

Lazy Mode:
Eager Mode:
        

we don't use this ddl from java
<property name="hbm2ddl.auto">create</property>:
    it will drop and create table so there is a data loss
<property name="hbm2ddl.auto">update</property>
    it will create table if does not exist
    else update the data in existing table
<property name="hbm2ddl.auto">create-drop</property>:
    same like create drop and create when session ended

