Hibernate notes:
Hibernate is an ORM (Object Relational Mapping) framework in Java used to map Java objects to relational database tables, reducing boilerplate SQL code and managing data persistence.

need two dependencies mysql connector j and hibernate core ORM

steps:
@Entity and @ID in pojo class
hibernate.cfg.xml-> will add all data related to url,username,password
Configuration
    -> configure(hibernate.cfg.xml)//config file
    ->configuration.addAnnotatedClass(Employees.class)//add pojo class
    ->buildSessionFactory
Session Factory
session

dirty checking:
    when we do update/change data after loading data from data base, without merge/pushing again db automatically updates
    because of persistent, so unless required don't modify data in db
States in Hibernate: 3 states we have
    1) transient:
        not associated with any session
        ex: Employee emp=new Employee()
    2) persistent:
        object is associated or linked with session
        ex: when we do session.persist(emp) or session.find(Employee.class,1)
        with persistent object we have problem of dirty checking
    3) detached:
        Objects gets detached when session is closed,
        session is closed there is no link between session and objects
        once session is closed there is no dirty checking problem

@Table:
    when your table name is diff in database and ClassName use this annotation over pojo class
    ex: @Table(name = "employees")
@Column:
    when column name and java class field name is diff we get error, so we need to use @Column over field
    ex: @Column(name = "salary")
         private double sal;

@GeneratedValue(strategy = GenerationType.IDENTITY):
    -generated value fetch the value generated by sql,used when we use auto increment in table id
    -to verify run in debug mode and check

HQL:
    for doing DQL or select operation we can use below method
        query=session.createSelectionQuery("from Employee where name=?1",Employee.class);
        query.setParameter(1,"sfks");
        list = query.list();
        System.out.println(list);

    for DML: insert,delete,Update
        session.beginTransaction();
        query=session.createMutationQuery("Insert into Employee(column1,coulumn2,etc) values(?1,?2,?3));
        query.setParameter(1,"sjfj");
        query.setParameter(2,"tester");
        query.setParameter(3,40000);
        query.executeUpdate()
        session.getTransaction().commit();


NativeQuery:
    original query - sql query
    this are same as HQL just method will change here
    session.createNativeQuery() for dql operations
    session.createNativeMutationQuery() for DML operation
    here we need to write sql query here 

    ex:session.createNativeQuery("select * from employees",Employee.class)

Note: In HQL we should give field/table name as per Entity/pojo class
      In Native Query we need to give table and column names as per Sql dataBase

Composite Primary key:
    its combination of two columns.
    In hibernate to do this we will write them in separate pojo class(@Embeddable) with Two columns that used in composite primary key
    use that class as has relationship in Entity class and above filed add annotation @EmbeddedID
    
Named Queries: like stored procedure
    execution will be faster here because precompiled query
    to do it add @NamedQuery annotation in Entity class and call that
    ex: @NamedQuery(name="allempl", query="from Employee") //Hql query
    @NamedNativeQuery(name="allempl", query="select * from Employee", resultClass= Employee.class) //sql query
    session.createNamedQuery("allempl",Employee.class);
    
    if you want to write multiple named queries,we can write inside brackets of @NamedQueries({@NamedQuery(),@NamedQuery()})
  
Mappings: we have four type of mappings, we use has a relationship here
    1. One to One:  
        unidirectional one to one: 
        person->passport(one person had one passport only)
        person and passport are seperate classes and we use Has a Relationship
        annotate @OneToOne over passport field in person class and @joinColumn(name="pass_id") to create a foreign key bw person and passport
        inside OnetoOne brackets we need to use cascading to persist or save passport object before person as it is using foreign key
        ex: @OneToOne(Cascade = caseCadetype.Persists)

        biDirectional One to One:
        if you try to access person details form passport we don't get bcz it unidirectional,
        to make bidirectional add person in passport as has a relation and add annotation @OneToOne(mappedBy="passPort")// mapped by means refer the person
        use two classes instance variable and set person and passport using setter methods
        and get person detail using getter method of passport
        
    2. One to Many:
        Person->Order( one person  can have many orders)
    3. Many to One:
        Order->Person( many orders can placed by one Person)


        ### ðŸ”ƒ Relationship Type:

        * This is a **bi-directional** relationship:

          * `Person â†’ Orders` â†’ **One-to-Many**
          * `Order â†’ Person` â†’ **Many-to-One**

        ---

        ### ðŸ”¹ Classes Involved:

        * `Person` (Parent)
        * `Order` (Child)

        ---

        ### ðŸ”¸ Step-by-Step Implementation:

        #### âœ… In `Person` class (One-to-Many side):

        ```java
        @OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
        private List<Order> orders;
        ```

        * `mappedBy = "person"` â†’ refers to the field name in `Order` class
        * `CascadeType.ALL` â†’ ensures all operations (persist, delete, etc.) cascade to child `Order` objects

        ---

        #### âœ… In `Order` class (Many-to-One side):

        ```java
        @ManyToOne
        @JoinColumn(name = "personId")
        private Person person;
        ```

        * `@JoinColumn` creates a **foreign key column** (`personId`) in the `Order` table
        * This makes the `Order` side the **owning side** of the relationship

        ---

        ### ðŸ“¦ Table Structure:

        **Table: Person**

        | personId | username |
        | -------- | -------- |
        | 1        | suresh   |

        **Table: Order**

        | orderId | productName | quantity | personId |
        | ------- | ----------- | -------- | -------- |
        | 1       | mobile      | 1        | 1        |
        | 2       | laptop      | 3        | 1        |

        ---

        ### ðŸ§ª How It Works:

        1. Create `Person` object.
        2. Create multiple `Order` objects.
        3. Set the `person` for each `Order` using `order.setPerson(person)`
        4. Add `Order` list to `person.setOrders(orderList)`
        5. Persist only the `Person` â€” Hibernate cascades to `Order`.

        ---


    4. Many to Many:
        students -> multiple courses
        courses-> multiple students

        * A **Trainee** can enroll in **multiple Courses**
        * A **Course** can have **multiple Trainees**

        ### ðŸ”¹ Tables Involved:

        * `trainee`
        * `course`
        * A **join table**: `trainee_courses` (to maintain the association)

        ---

        ### ðŸ”¸ Unidirectional Many-to-Many:

        Only one side (e.g., `Trainee`) knows about the relationship.

        ```java
        @ManyToMany
        @JoinTable(name = "trainee_courses",
                   joinColumns = @JoinColumn(name = "traineeID"),
                   inverseJoinColumns = @JoinColumn(name = "courseID"))
        private List<Course> courses;
        ```

        * `@JoinTable` creates the **intermediate mapping table**
        * `joinColumns` â†’ column in join table referring to current entity (`trainee`)
        * `inverseJoinColumns` â†’ column referring to the other entity (`course`)

        > âœ… Use `CascadeType.ALL` if you want Hibernate to persist both `Trainee` and related `Courses` in one go.

        ---

        ### ðŸ”¸ Bidirectional Many-to-Many:

        Both entities are aware of the relationship.

        **In `Trainee` class:**

        ```java
        @ManyToMany(cascade = CascadeType.ALL)
        @JoinTable(name = "trainee_courses",
                   joinColumns = @JoinColumn(name = "traineeID"),
                   inverseJoinColumns = @JoinColumn(name = "courseID"))
        private List<Course> courses;
        ```

        **In `Course` class:**

        ```java
        @ManyToMany(mappedBy = "courses")  // 'courses' is the field in Trainee
        private List<Trainee> trainees;
        ```

        > ðŸ”„ `mappedBy` tells Hibernate that `Course` is the **inverse side** of the relationship and no separate join table should be created here.

        ---

        ### ðŸ§ª How It Works:

        1. You create `Trainee` and `Course` objects
        2. Assign `List<Course>` to each `Trainee`
        3. Assign `List<Trainee>` to each `Course`
        4. Persist any one side (usually the owning side: `Trainee`) â€” Hibernate handles the join table

        ---



Lazy Mode: by default it will be in lazy mode only when find person we should get only person details not orders
            in lazy mode it wont fetch orders first if call getOrders() then again it will call db and fetch orders
Eager Mode: if you set fetch= "eager" in @ oneToMany then it will try to fetch the order data from data base even its not required
        

we don't use this ddl from java
<property name="hbm2ddl.auto">create</property>:
    it will drop and create table so there is a data loss
<property name="hbm2ddl.auto">update</property>
    it will create table if does not exist
    else update the data in existing table
<property name="hbm2ddl.auto">create-drop</property>:
    same like create drop and create when session ended

